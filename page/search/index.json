[{"content":"郝斌C语言笔记\n#inlude \u0026lt;stdio.h\u0026gt;\nwifi down rmmod monitor rmmod wifi_3_0 rmmod wifi_2_0 rmmod qca_ol insmod qca_ol testmode=1 insmod wifi_3_0 insmod diagchar diag_socket_app -a 192.168.1.55 \u0026amp; /etc/init.d/ftm start ftm -n -dd \u0026amp; 指针的概述\n#define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; int main() { int* p;\t//p是变量的名字，int * 表示p变量存放的是int 类型变量的地址 //int * p; 不表示定义了一个名字叫做*p的变量 //int * p; 应该这样理解：p是变量名，p变量的数据类型是 int * 类型 //所谓int *类型 实际就是存放int变量地址的类型 int i = 3; int j; p = \u0026amp;i; /* 1. p保存了i的地址，因此p指向i 2. p不是i，i也不是p，更准确的说：修改p的值不影响i的值，修改i的值也不影响p 3. 如果一个指针变量指向了某个普通变量，则 *指针变量\t就完全等同于\t普通变量 例子： 如果p是个指针变量，并且p存放了普通变量i的地址 则p指向了普通变量i *p 就完成等同于 i 或者说：在所有出现*p的地方都可以替换成i 在所有出现i的地方都可以替换成*p */ j = *p; printf(\u0026#34;i = %d, j = %d\\n\u0026#34;, i,j); return 0; } 指针就是地址，地址就是指针 地址就是内存单元的编号\nasscii 这个叫编码\n指针变量是存放地址的变量 指针和指针变量是两个不同的概念 但是要注意： 通常我们叙述时会把指针变量简称为指针，实际它们的含义并不一样。\n指针和指针变量的关系 动态内存分配\n20240329 ############################ P122 指针的重要性\n表示一些复杂的数据结构。 学数据结构必须要学习指针 快递的传递数据\n是函数返回一个以上的值 能直接访问硬件 能够方便的处理字符串 是理解面向对象语言中引用的基础\n总结： 指针是C语言的灵魂\n指针的定义 地址：内存单元的编号 从0开始的非负整数 范围：内存条是多大 CPU \u0026mdash;内存条 控制线 数据线 地址线\n地址线如果处理： 内存里 一个单元是一个字节，8位 一根线是0，1 两根线是四个组合 几根线，2的几次方， 指针：\n指针的分类 1.基本类型的指针 重要 2.指针和数组 3.指针和函数 4.指针和结构体 重要 5.多级指针\n##########################\n经典的指针互换两个数\n#define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; //经典指针程序互换两个数 //void huhuan_1(int a,int b) //不能实现互换 //{ //\t//int t; // //\t//t = a; //\t//a = b; //\t//b = t; //只是改变了形参的值，不能改修主函数的实参 // //\treturn; //} void huhuan_2(int* p, int* q) //不能实现互换 { int t; //t = p; //p = q; //q = t; //只是把p,q的值改了而已，不能换算 t = *p; //p是int*类型，*p 的是int *p = *q; *q = t; return; } int main() { int a = 3; int b = 5; /*huhuan_1(a,b);*/ //huhuan_2(a,b); //也是错误的 huhuan_2(\u0026amp;a, \u0026amp;b); //也是错误的 printf(\u0026#34;a=%d, b=%d\u0026#34;, a, b); return 0; } 指针使函数返回一个以上的值\n如果经过被调函数修改主调函数普通变量的值 1.实参必须为该普通变量的地址 2.形参必须为指针变量 3.在被调函数中，通过 *形参名字方式，就可以修改主调函数相关变量的值\nP131\n一维数组和指针 一维数组名 是指针常量，它存放的是一维数组的第一个地址\n下表和指针的关系 如果p是个指针变量， 则p[i] 永远等价于 *(p+i)\n确定一个一维数组需要几个参数。 如果一个函数要处理一个一维数组，则需要接收该数组的哪些信息？ 还有要个数 数组的第一个元素首地址，数组的长度 一定要明白 10行的pArr[3], 和17行 19行的a[3]是同一个变量\nvoid f(int* arr, int len) { arr[3] = 88; //arr[3] 等价与*(arr+3); } int main() { int a[6] = { 1,2,3,4,5,6 }; printf(\u0026#34;%d\\n\u0026#34;, a[3]); f(a, 6); printf(\u0026#34;%d\\n\u0026#34;, a[3]);//a[3] 等价与*(a+3) return 0; } pArr[i] 等价于*(pArr+i) 等于是拷贝了一份\nvoid f(int* pArr, int len) { int i; for (i = 0; i \u0026lt; len; ++i) { printf(\u0026#34;%d \u0026#34;, *(pArr + i)); //*(pArr+i), 等价与pArr[i], 也等价与b[i],也等价与*(b+i) printf(\u0026#34;%d \u0026#34;, pArr[i]); //等价 } printf(\u0026#34;\\n\u0026#34;); } int main() { int a[5] = { 1,2,3,4,5 }; int b[6] = { -1,-2,-3,4,5,-6 }; int c[100] = { 1,99,22,33 }; f(b, 6); return 0; } 指针变量的运算 指针变量不能相加，不能相乘，也不能相除 如果两个指针变量指向的是同一个连续空间的不同存储单元，则这两个指针变量才可以相减。 预备知识： sizeof(数据类型) 功能：返回值就是该数据类型所占的字节数 例子sizeof(int)=4 sizeof(char)=1 sizeof(double)=8 sizeof(也可以写变量名) 功能：返回值该变量所占的字节数 指针变量都是占用4个字节 一个指针变量兜底占几个字节 假设p指向char类型变量 1 假设q指向int类型变量 4 假设r指向double类型变量 8 #include \u0026lt;stdio.h\u0026gt; //int main() //{ //\tint i = 5; //\tint j = 10; //\tint* p = \u0026amp;i; //\tint* q = \u0026amp;j; // //\tint a[5]; //\tp = \u0026amp;a[1]; //\tq = \u0026amp;a[4]; // //\tprintf(\u0026#34;p和q所指向的单元相隔 %d 个单元\\n\u0026#34;, q - p); // //\treturn 0; //} int main() { char ch = \u0026#39;A\u0026#39;; int i = 99; double x = 66.6; char* p = \u0026amp;ch; int* q = \u0026amp;i; double* r = \u0026amp;x; printf(\u0026#34;%d %d %d\\n\u0026#34;, sizeof(p), sizeof(q), sizeof(r)); return 0; } 输出都是 4 4 4\n只是保存首字节的编号\n指针和二维数组，这个难度大 *******************和流程控制一样重要 动态内存分配 重要\n传统数组的缺点： 1.数组长度必须事先指定，且只能是长整数，不能是变量 C99后可以是变量\n2.传统形式定义的数组，该数组的内，存程序员无法手动释放，数组一旦定义，系统会为该数组分配的存储空间就会一直存在，除非数组所在的函数运行结束。 在一个函数，运行期间，系统为该函数中数组所分配的空间会一直存在，知道该函数运行完毕时，数组的空间才会释放。\n3.数组的长度一旦定义，其长度就不能再更改 数组的长度不能再函数运行的过程中动态的扩充或缩小 4.A函数定义的数组，在A函数运行期间可以被其他函数使用 但A函数运行完毕之后，A函数中的数组将无法再被其他函数使用。 传统方式定义的数组不能跨函数使用。\n为什么需要动态内存分配 动态数组很好的解决啦传统数组的这4个缺陷 动态内存分配举例 动态数组的构造 malloc 是 memory(内存) allocate(分配的缩写) #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; int main() { int i = 5; //分配了4个字节，静态分配。 int* p = (int*)malloc(4); //动态分配 free(p); //表示把p所指向的内存给释放掉， printf(\u0026#34;同志们好！\\n\u0026#34;); return 0; } 1.要是用malloc函数，必须添加malloc.h这个头文件 2.malloc函数只有一个形参，并且形参是整型 3.4表示请求系统为本程序分配4个字节 4.malloc函数只能返回第一个字节的地址 5.强制类型转换int*,12行分配了8个字节，p变量占4个字节，p所指向的内存也占4个字节。 6.p本身所占的内存是静态分配的，p所指向的内存是动态分配的。p本身的内存是静态的，不能由程序员手动释放，只能在程序运行完自动释放。 静态内存和动态内存的比较\n跨函数使用内存的问题\n动态内存分配一维数组 多级指针\nint main() { int i = 0; int* p = \u0026amp;i; int** q = \u0026amp;p; int*** r = \u0026amp;q; ***r = 20; printf(\u0026#34;%d\\n\u0026#34;, ***r); return 0; } 静态变量不能跨函数使用指针\nvoid f(int** q)\t//q是个指针变量，无论q是什么类型的指针变量，都只占4个字节 { int i = 5; //*q等价于p q和**q都不等价于p //*q=i; //error 因为*q等价于i;等价于p=i； 这样写是错误的，静态变量不能跨函数。 *q = \u0026amp;i; 只是保存首字节的编号 2. 指针和二维数组，这个难度大 *******************和流程控制一样重要 } int main() { int* p; f(\u0026amp;p); printf(\u0026#34;%d\u0026#34;, *p);//本语句语法没有问题，但逻辑上有问题 return 0; } P148 动态内存可以跨函数使用 void f(int** q) { *q = (int*)malloc(sizeof(int)); //等价于p=(int*)maclloc(sizeof(int)) //q = 5;;\t// 错误 //*q = 5;\t//p=5; 错误 **q = 5;\t//*p=5; 正确 } int main() { int* p; f(\u0026amp;p); printf(\u0026#34;%d\u0026#34;, *p); return 0; } 内存的栈，堆的重新学习理解 栈区，堆区，静态区 重新巩固学习\nP150 为什么需要结构体 为了表示一些复杂的实物，而普通的基本类型无法满足需求\n什么叫结构体 把一些基本类型数据组合在一起形成的一个新的复合数据类型，这个叫做结构体 如何定义结构体 //第一种 推荐 struct Student { int age; float score; char sex; }; //第二种 struct Student2 { int age; float score; char sex; }st2; //第三种 struct { int age; float score; char sex; }st3; int main() { struct Student st = { 80,66.6,\u0026#39;F\u0026#39; }; //st是结构体变量 基本类型组成成一个新的数据类型 return 0; } 怎么使用结构体变量 赋值和初始化 struct Student { int age; float score; char sex; }; int main() { struct Student st = { 80,66.6,\u0026#39;F\u0026#39; }; //初始化，定义的同时赋，st是结构体变量 基本类型组成成一个新的数据类型 struct Student st2; st2.age = 10; st2.score = 88; st2.sex = \u0026#39;F\u0026#39;; printf(\u0026#34;%d %f %c\\n\u0026#34;, st.age, st.score, st.sex); printf(\u0026#34;%d %f %c\\n\u0026#34;, st2.age, st2.score, st2.sex); return 0; } 如何取出结构体变量中的每一个成员 1结构体变量名.成员名 2结构体变量名-\u0026gt;成员名 结构体变量的运算 郝斌C语言学习大纲 https://blog.csdn.net/houjingchuan/article/details/122524318\n举例 动态结构存放学生信息的结构体数组\n通过函数完成对结构体变量输入和输出 应该发送内容还是发送地址，发送地址占用内存小 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void InputStudent(struct Student* pstu); //void OutputStudent(struct Student ss); //不修改，可以发送地址，也可以发送地址 void OutputStudent(const struct Student* ss); struct Student { int age; char sex; char name[100]; }; int main() { struct Student st; //printf(\u0026#34;%d\\n\u0026#34;, sizeof(st)); //发送内容的话，是st的总大小 InputStudent(\u0026amp;st);\t//对结构体变量输入 ,必须发送st的地址 //printf(\u0026#34;%d %c %s\\n\u0026#34;,st.age,st.sex,st.name); //OutputStudent(st); //对结构体变量输出，可以发送地址，也可以发送数值 //但是发送地址只占用4个字节，发送数值是st的总大小，发送地址耗用内存小，发送内容大 OutputStudent(\u0026amp;st); return 0; } void InputStudent(struct Student * pstu) //pstu只占4个字节 ，只用首字节表示 { //(*pstu).age = 20; //等价于pstu-\u0026gt;age pstu-\u0026gt;age = 10; pstu-\u0026gt;sex = \u0026#39;F\u0026#39;; strcpy(pstu-\u0026gt;name, \u0026#34;张三\u0026#34;);\t//不能写成stu.name = \u0026#34;张三\u0026#34;； } //void OutputStudent(const struct Student ss) //{ //\tprintf(\u0026#34;%d %c %s\\n\u0026#34;, ss.age, ss.sex, ss.name); //} void OutputStudent(const struct Student* ss) //加const 禁止修改 { printf(\u0026#34;%d %c %s\\n\u0026#34;, ss-\u0026gt;age, ss-\u0026gt;sex, ss-\u0026gt;name); } 指针： 指针的重要性 表示一些复杂的数据结构 快速的传递数据 使函数返回一个以上的值 能直接访问硬件 能够方便立即字符串 是理解面对对象语言中引用的基础 总结 指针是C语言的灵魂 结构体变量的运算 结构体变量不能相加，不能相减，也不能相互乘除 但结构体变量可以相互赋值 struct Student st;\n冒泡排序 #include \u0026lt;stdio.h\u0026gt; void sort(int* a,int len) { int i, j,t; for (i = 0; i \u0026lt; len - 1; ++i) { for (j = 0; j \u0026lt; len - 1 - i; ++j) { if (a[j] \u0026gt; a[j + 1]) { t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; } } } } int main() { int a[6] = { 10,2,8,-8,11,0 }; int i = 0; sort(a,6); for (i = 0; i \u0026lt; 6; ++i) { printf(\u0026#34;%d \u0026#34;,a[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } ","date":"2024-03-29T10:55:16-04:00","permalink":"https://fangsheng009.github.io/post/20240329-2255-%E9%83%9D%E6%96%8Cc%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/20240329_%E9%83%9D%E6%96%8Cc%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/","title":"郝斌C语言笔记"},{"content":" 未安装QTI的IQ，使用QDART不能正常加载\n安装LitePoint_QTI_SCPI后的状态\n","date":"2024-03-26T10:34:25-04:00","permalink":"https://fangsheng009.github.io/post/20240326-2228_qdart-%E9%93%BE%E6%8E%A5iq%E4%BB%AA%E5%99%A8%E5%AE%89%E8%A3%85qti%E6%96%B9%E6%B3%95/20240326-2228_qdart-%E9%93%BE%E6%8E%A5iq%E4%BB%AA%E5%99%A8%E5%AE%89%E8%A3%85qti%E6%96%B9/","title":"QDART-加载IQ仪器安装QTI方法"},{"content":"什么是C语言\n第一个C语言程序\n数据类型\n变量、常量\n低级语言，高级\n汇编指令，B语言，C语言\n10001010 ADD 高级语言\nC语言的国际标准\nANSI\nC89 C90 C99 C11\nC89 C90\n编译器 Clang GCC WIN-TC SUBLIME MSVC TURBO C\n编辑器和编译器不一样\nCtrl+F5 开始执行不调试。F5是调试\n3\\ 数据类型\nChar\nShort 短整型\nInt\nLong\nLong long\nFloat 单精度浮点型\nDouble 双精度浮点型\n为什么写代码\n为了解决生活中的问题，购物、点餐、看电影、\n书 鹏哥C语言的书记 66块。\n66 是整数 整型\n66.6小数 浮点型\n书名 字符串 字符型\nOpenwrt@#\n6.66\nCtrl + K, 在Ctrl + C: 将选中的行全部注释\nCtrl + K, Ctrl + U: 取消选中的行的注释\n计算机中的单位\nBit 比特位\nByte 字节\nKb\nMb\nTb\npb\n计算机能理解二进制\n我们生活在十进制的世界\n0~9\n66\n二级制的世界\n只有0 1\n八进制\n0~7\n十六进制\n0~F F是15\n8个bit等于1byte\n00 0\n01 1\n10 2\n11 3\n向内存申请空间\n创建变量的本质是向内存申请空间\n变量和常量\n变量的分类\n局部变量\n全局变量\n当全局变量和局部变量名字相同时，局部变量优先\n_CRT_SECURE_NO_WARNINGS\n在源文件的第一行放#define _CRT_SECURE_NO_WARNINGS\nScanf 这个是VS编译器自己提供的函数，非标准C提供的函数，那也就是只有VS编译器能认识\n如果你非要使用scanf_s 请你研究一下再使用\n在VS安装路径下 newc++file.cpp文件\n在VS工程中创建新的.c或者.cpp文件的时候，都是拷贝new\n变量的作用域和变量的生命周期\n局部变量 限定这个名字的可用性的代码 全局变量 变量的生命周期\n局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束\n全局变量\n在生个生命周期都是存在的，都是你可以用的\n字面常量\nConst 修饰的常变量\n不能再修改\n枚举常量 4字符串+转义字符+注释\nCtrl +F10 调试模式，打开监视窗口\nctrl+F11 进入单行调试\n栈区，堆区，静态区\n影响了变量的生命周期，生命周期变长，和程序的生命周期一样\n一个内存单元的大小是一个字节\n32位电脑\nXXXX XXXX XXXX XXXX XXXX XXXX\n.h .c编译成静态库\n配置编译出静态库lib\n改为\nCtrl+ F7\nCtrl+F5\nhttps://www.bilibili.com/video/BV1Vm4y1r7jY/?p=44\u0026spm_id_from=pageDriver\u0026vd_source=afe65db66339e30b541134f2a216daaa\n把.h和.lib放到\n加上这句函数\n函数的栈帧的创建和销毁\n数组的编号是从0开始的\n判断输赢\n算法的实现 二级指针 二级指针变量是用来存放，一级指针变量的地址的\n指针数组: 存放指针的数组就是指针数组。\nVS2019快捷键\nctrl\nint arr[10]\nint *parr[10]={\u0026amp;a,\u0026amp;b,\u0026amp;c};\n//parr 就是看存放指针的数组\n第七节 结构体\n结构体的基础知识， 结构体类型的声明 结构体的初始化 结构体的成员访问 结构体传参\n结构是一些值的结合，这些值成为成员的变量，结构的每个成员可以是不同类型的变量\n结构是一种集合\n数组是一组相同类型元素的集合 结构是不同类型元素的\n复杂对象\nstruct Peo { char name[20]; char tele[12]; char sex[5]; int high; }p1,p2;\nint main() { struct Peo p1={0};\nreturn 0; }\n代码的调试，bug 找bug的过程，调试 所有发生的事情一定有迹可循，如果问心无愧，就不需要掩盖也就没有迹象啦，如果问心有愧，就必然需要掩盖，那就一定会有迹象，迹象越多就越容易顺腾而上，这就是推理的途径。顺着这条途径顺流而下就是犯罪，逆流而上，就是真相\n一名优秀的程序员是一名出色的侦探 每一次调试都是尝试破案的过程。\n我们是如果写代码的 不与奥给我说什么底层原理，框架内核，老夫敲的代买就是一把，复制，粘贴，拿起键盘就是干\n有事如何排查出现的问题\n神秘的程序员门\n拒绝 迷信式调试\n调试是什么 调试又称除错，是发现和减少计算机程序或电子仪器设备中程序错误的过程。\n调试的基本步骤\n写程序的风险，严谨的，\ndebug和release的版本介绍\ndebug通常为调试版本，他包含调试信息，并且不作任何优化，便于程序员调试程序。 release称为发布版本，它往往\n发现程序错误的存在 以隔离，消除等方式对错误进行定位 确定错误产生的原因 提出纠正错误的解决办法 对程序错误予以改正，重新测试\n程序员自己 测试人员 用户\n快捷键 F5 启动调试，是和F9配合一起用的 F9 创建断电和取消断点\nwifi down rmmod monitor rmmod wifi_3_0 rmmod wifi_2_0 rmmod qca_ol insmod qca_ol testmode=1 insmod wifi_3_0 insmod diagchar diag_socket_app -a 192.168.1.55 \u0026amp; /etc/init.d/ftm start ftm -n -dd \u0026amp; 如何写好易于调试的代码\n优秀的代码 1、代码运行正常 2、bug很少 3、效率高 4、可读性高 5、可维护性高 6、注释清晰 7、文档齐全\n编译常见的错误\nC语言进阶 release版本会优化，这个补充下\n源码 反码 补码 （反码+1）\n内存中存储的都是补码\nC C语言实现简单的数据结构 ，C++, C++ STL 高级数据结构，计算机网络（网络协议+网络编程），LINUX(操作系统，系统编程)+数据库（MySQL）+实战项目 450小时\n测开\n大小端\n数据存储 浮点数类型\nC语言实现简单数据结构\n指针+结构体+动态内存管理 必须要摸透\n《C陷阱和缺陷》\n函数指针\n（（void()（）int））(int);\n函数指针数组，也是指针\n指向 函数指针数组 的指针\n回调函数\nqsort排序程序的使用\n冒泡程序的改进 void base\n【C语言程序设计从入门到进阶【比特鹏哥c语言2024完整版视频教程】（c语言基础入门c语言软件安装C语言指针c语言考研C语言专升本C语言期末计算机二级C语言c语言】https://www.bilibili.com/video/BV1Vm4y1r7jY?p=114\u0026amp;vd_source=7662e66d3417298d89c410060b9dceb0\n字符串函数和字符串函数 求字符串疮毒的函数 strlen\nstrcpy\nC语言标准库函数\nhttps://zh.cppreference.com/w/c/header\nhttps://blog.csdn.net/2302_79637129/article/details/136492137\nC语言标准库函数\nhttps://zh.cppreference.com/w/c/header\nhttps://blog.csdn.net/2302_79637129/article/details/136492137\nhttps://cplusplus.com/reference/\nhttps://legacy.cplusplus.com/reference/clibrary/\nhttps://cplusplus.com/reference/\nstrcmp 比较两个字符串 比较的是ascii码的值\n长度受限制的字符串函数 strncpy 复制过来覆盖 strncat 复制过来追加 strncmp 字符串比较 strstr查找字符串 ，找到后从首地址开始打印后面的\nKMP算法 这个算法也是用来实现在一个字符串中查找子字符的，有空可以研究下\n效率高，但是代码学习困难 B站搜索 比特大博哥 可以找到KMP算法的实现。\nstrtok 切割字符串的 char *strtok( char *strToken, const char *strDelimit );\nstrerror 返回错误码，所对应的错误信息 errno.h头文件\nC语言的库函数，在执行失败的时候，都会设置错误码\n字符分类函数 iscntrl isspace isdigit isxdigit islower isupper isalpha isalnum ispunct isgraph isprint\n程序员的思维严谨 出去买五个馒头，如果遇到西瓜，买一个\n需求澄清会，问题问清楚，沟通的重要性\nisspace\n字符转换\ntolower\nmemcpy 内存拷贝\nvoid * memcpy ( void * destination, const void * source, size_t num );\n重叠内存的拷贝 memmov 函数的实现，用来复制重叠的数据拷贝\nmemcmp 函数内存比较\nmemset 只定一个内存块存放，新申请的内存区域\n自定义类型 结构体的声明，联合体，枚举\n数据在内存中的存储结构\n线型 顺序表 链表\n树形 二叉树\n结构体的自引用\n结构体变量的定义和初始化 有了结构体类型，那如何定义变量\n结构内存的对齐 VS默认 的对齐是8\noffsetof 返回的是变异量\n平台原因 移植原因\n性能原因 数据结构(尤其是栈)应该尽可能地在自然边界上对齐 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。 总体来说，结构体的内存对齐是拿空间来换取时间的做法。\n那设计的时候，我们纪要满足对齐，又要节省空间 让占用空间小的成员尽量集中在一起。\n#pragma pack(4) 这个预处理就是修改默认对齐 4,可以修改\n头文件中使用，功能是：防止头文件被多次引用\n位段 位段其实是可以节省空间的，同一类型 注重可移植的程序应该避免使用位段\n16位和32位系统的，位段中最大位的数，不能确定\n跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。\n位段的应用，可以写更多的代码适应不同的平台\n位段的应用\n通讯录练习实现\n人的信息 名字 年龄 性别 电话 地址 1、存放100个人的信息 2、增加联系人 3、删除指定联系人 4、查找联系人 5、修改联系人 6、排序 7、显示联系人\n枚举 枚举类型的定义 enum Day {\n}\n联合体 union 不会同时用\n重要的三个 指针 结构体 动态内存开辟\n学习数据结构\n动态内存函数的介绍 malloc 可以维护空间的大小 free calloc 有初始化的功能 =malloc + memset realloc 调整内存 找新的空间，复制参数后，返回新的空间地址，释放旧的地址，需要接收新的地址。如果连续的空间够，就用原来的地址\n内存池\n柔性数组\n陈浩个人博客 酷壳 COOLSHELL\n文件操作\nfgetc 字符输入函数 fputc 字符输出函数 fgets 文本行输入函数 fputs 文本输出函数 fscanf 格式化输入函数 fprintf 格式化输出函数 fread 二进制输入 fwrite 二进制输出\n对比 scanf 是针对标准输入的格式化输入语句 printf 是针对标准输出的格式化输出语句\nfscanf 是针对所有输入流的格式化输入语句 fprintf 是针对所有输出流的格式化输出语句\nsscanf 从一个字符串中转化出一个格式化的数据 sprintf 把一个格式化的数据转化成字符串\n文件的随机读取，跳到为止读取 fseek\nftell 偏移量 文件查看现在位置在哪里\nrewind 地址回到起始位置\n文本文件和二进制文件\n预处理\noffsetof宏的\nfflush刷新缓冲区，不同的编译器，缓冲区会不一样\n程序的预编译 编译原理，在有操作系统的环境中，一般这个由操作系统完成，在独立的环境中，程序的载入\n《程序员的自我修养》\n运行环境 程序执行的过程 程序必须载入内存\n预处理阶段 详解\n宏是没有办法调试的\n","date":"2024-03-19T15:47:46-04:00","permalink":"https://fangsheng009.github.io/post/demo/demo/","title":"C 语言学习笔记"},{"content":"关闭WIFI-1463\u0026quot;\t手机-11 关闭WIFI-1163\u0026quot;\t手机-1463 联通SIM卡\t福州联通\t109.47\t105.02\t104.35\t107.82\t208.03\t63.82\t104.37\t30.03\t255.15\t76.5 99.46\t109.28\t117.03\t107.75\t244.68\t73.39\t104.56\t24.46\t243.99\t68.27 106\t109.71\t124.27\t104.98\t253.13\t65.88\t106.15\t26.89\t246.26\t89.12 113.75\t104.72\t220.63\t51.05\t108.65\t19.75\t239.3\t91.63 124.65\t108.83\t224.7\t79.69\t108.8\t21.31\t233.08\t90.04 无锡联通\t59.33\t111.15\t65.03\t107.63\t56.49\t109.71\n12V 3A 工作温度范围 : -20~55℃ 储存温度范围 : -40~85℃ 储存湿度范围: 5~95% 无冷凝 工作湿度范围: 5~95% 无冷凝 IPQ5018+QCN6102+AR8033 无线PHY：内置 外置PA型号：FEM：QPF4288A 外置LNA型号：内置 外置RF switch型号：内置 无线PHY： 外置PA型号：FEM：QPF4588A 外置LNA型号： 外置RF switch型号： M.2接口 5G模块用高通X55，同时考虑X62的模块 外置 4Gbit DDR3 SDRAM 512MB SPI:NOR FLASH 8MB NAND flash 128MB \u0026ldquo;以太网PHY： AR8033 LAN1/支持10/100/1000Mbps 自适应\nWAN1/支持10/100/1000Mbps 自适应\u0026rdquo;\n","date":"2024-03-17T15:47:46-04:00","permalink":"https://fangsheng009.github.io/post/mt7628-wifi%E6%A0%A1%E5%87%86/mt7628-wifi%E6%A0%A1%E5%87%86/","title":"MT7628-WIFI校准"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","permalink":"https://fangsheng009.github.io/post/chinese-test/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://fangsheng009.github.io/post/markdown-syntax/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://fangsheng009.github.io/post/markdown-syntax/","title":"Markdown Syntax Guide"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://fangsheng009.github.io/post/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }","date":"2019-03-05T00:00:00Z","image":"https://fangsheng009.github.io/post/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://fangsheng009.github.io/post/emoji-support/","title":"Emoji Support"}]